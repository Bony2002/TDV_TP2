---
title: ''
output:
  word_document: default
  html_document: default
date: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## TP2: Logística centralizada de primera milla

### Introducción al problema

La problemática a abordar se trata de encontrar la manera óptima, o en su defecto efectiva, de realizar una asignación. Trabajaremos sobre un caso particular en el cual buscamos asignar un conjunto $N$ de negocios a un conjunto $M$ de depósitos. Cada negocio posee una distancia a cada depósito, denotada por $c_{ij}$, con $i\in{M}$ y $j \in{N}$. También posee una demanda, $d_{ij}$ que se refiere a la cantidad de stock que el negocio pedirá de dicho depósito. Por último, cada depósito posee un capacidad, denotada por $c_i$. En el este caso particular, los negocios no pueden pedir stock de distintos depósitos, por lo cual serán asignados tan solo a uno de estos. Asimismo, la demanda de cada negocio será la misma para todo depósito, por lo cual la variable $d_{ij}$ no depende de $i$ y podría escribirse como $d_j$. Consideramos una solución óptima al problema de asignación a aquella que minimiza la suma de las distancias entre cada negocio y cada depósito asignados, teniendo en cuenta no exceder la capacidad de estos últimos.

El tipo de problema con el cual trataremos es conocido como *GAP* (Generalized Assignment Problem), y su versión de optimización se encuentra en la categoría NP-Hard. Esto quiere decir que todo problema perteneciente a la clase NP puede ser reducido polinomialmente a *GAP*. Además, un problema NP-Hard no necesariamente pertenece a NP, es decir que no necesariamente existe un algoritmo polinomial para verificar un certificado positivo de una instancia del problema. Si encontraramos un algoritmo polinomial para *GAP* entonces encontraríamos una solución polinomial para todo problema en NP y demostraríamos que P = NP. De todos modo, eso aún no ha sucedido y es por eso que se desarrollan heurísticas para resolver el problema *GAP,* buscando un balance entre la complejidad temporal y la calidad de la solución.

En el siguiente trabajo buscamos modelar distintas alternativas de heurísticas y búsquedas locales en pos de hallar una solución de cierta calidad para la problemática GAP, en tiempo polinomial. Comenzaremos diseñando heurísticas constructivas, luego operadores de búsqueda local y por último generaremos una metaheurística que los englobe.

### Diseño de heurísticas constructivas

#### Heurística 1: depósito más cercano

En primer lugar diseñamos e implementamos una heurística cuyo funcionamiento es el siguiente: por cada negocio buscamos el depósito más cercano, es decir aquel cuyo $c_{ij}$ sea el menor, y asignamos el negocio a dicho depósito. Asimismo, vamos disminuyendo la capacidad $c_j$ del depósito en función a la demanda $d_{ij}$ de la asignación. En caso de que el depósito de menor distancia a un negocio no tenga capacidad restante suficiente, este sería asignado al próximo depósito más cercano.

Esta heurística es posiblemente la más intuitiva, y tiene ciertas ventajas como no necesitar actualizar una lista de disponibilidad, ya que los depósitos pueden tener tantos negocios asignados como su capacidad permita. En otros enfoques, es necesario llevar la cuenta de qué negocios ya fueron asignados, pero en este caso al iterar por negocios y en cada iteración asignarlos a un depósito, no tenemos dicho problema.

La complejidad de este algoritmo goloso es $O(n m)$ siendo $n$ la cantidad de negocios y $m$ la cantidad de depósitos. Como vemos, es polinomial. Claramente no encontraremos la solución óptima, pero encontraremos una solución que creemos que tendrá cierto grado de efectividad.

#### Heurística 2: negocio más cercano

En segundo lugar desarollamos una heurística que funciona de manera inversa a la primera, es decir que itera por cada depósito y le asigna aquellos negocios que se encuentren cerca, mientras la capacidad del depósito lo permita. Es importante asegurarse que no se evalúen aquellos negocios que ya han sido asignados, por lo cual debemos llevar la cuenta de estos. Además, es necesario encontrar un modo de definir qué quiere decir que un negocio está cerca de un depósito. Nuestro criterio fue el siguiente: por cada depósito, ordenamos los negocios en función a cuán lejos estan de este, de menor a mayor. Así, iteramos por los depósitos asignandoles en orden los negocios mientras estos aún no esten asignados y mientras la capacidad del depóstio sea mayor a la demanda del negocio. A grandes rasgos, asignamos a cada depósito los negocios más cercanos a él.

La complejidad de este algoritmo goloso es de $O(n^2m)$, polinomial pero no tan eficiente como la heurística anterior.

Analizando el funcionamiento de neustra heurística, llegamos a la conclusión de que el orden en que evaluamos los depósitos alterará el resultado. Luego, quizás podríamos definir un orden de manera que ayude a reducir aún más el valor de la función objetivo. El primer depósito tenido en cuenta tendrá prioridad sobre los otros y será probablemente el único que tenga todos los negocios más cercanos a él asignados. Imaginemos la situación en la cual existe un depósito considerablemente más alejado de los negocios que el resto. Si este depósito es considerado antes que el resto, se le asignarán múltiples negocios que a pesar de estar más cerca del depósito que otros negocios, claramente estarán más cerca de los otros depósitos que de aquel en cuestión. Así, estaríamos dando mucho peso a un depósito al cual deberíamos tratar de asignarle la menor cantidad de negocios posibles. Luego, podría ser útil ordenar los depósitos según distancia promedio a los negocios y comenzar por aquellos con menor promedio. Así, evitarímos situaciones como la descripta anteriormente. Aquí partimos de la base de que la suma de las capacidades de los depósitos sea mayor a la suma de las demandas de los negocios, por lo cual preferimos que los depósitos "más vacíos" sean aquellos más lejanos. Si la situación fuera diferente entonces priorizar por cercanía los depósitos quizás no se necesario.

#### Consideraciones

Se pueden diseñar heurísticas que tomen un enfoque reacionado a las demandas que tiene cada negocio en relación a cada depósito, buscando quizás asignar negocios a depósitos de los cuales ocupen menor capacidad si es que dichos depósitos son cercanos a otros negocios y buscamos asignarlos a la mayor cantidad posible de negocios. Pueden surgir muchos matices considerando las demandas y capacidades. De todos modos, a pesar de que en el problema general de GAP las demandas de los negocios pueden variar dependiendo del depósito, como en nuestra instancia real todo negocio demanda lo mismo de cualquier depósito, no profundizaremos en estas alternativas. A pesar de estar diseñando una heurística para GAP en general, nuestro objetivo final se refiere en específico a la instancia particular de *ThunderPack*.

### Operadores de búsqueda local

#### Operador 1: relocate

El primer operador que definimos es un relocate. Este itera por los negocios evaluando si hay algún depósito con menor distancia al negocio que aquel al cual se encuentra asignado actualmente, y en caso afirmativo, si las capacidades lo permiten, asigna el negocio a su nuevo depósito. Definimos como vecindario a todas las soluciones alcanzables desde mi solución actual haciendo un único relocate. Utilizamos como criterio de aceptación el *first improvement*, y por lo tanto apenas hallamos una solución mejor a la actual redifinimos nuestra solución como la nueva y continuamos explorando su nuevo vecindario.

Para aceptar una nueva solución debemos evaluar 2 condiciones, con $i_1$ el depósito anterior, $i_2$ el nuevo depósito y $j$ el negocio:

-   $c_{i_2j} < c_{i_1j}$

-   $d_{i_2j} \leq c_{i_2}$ , siendo $c_{i_2}$ la capacidad restante del depósito $i_2$

Este operador no aportará una mejora con toda heurística posible como base para la solución inicial. Por ejemplo, si tomamos nuestra primer heurística, como cada negocio está asignado al depósito más cercano, nunca encontraremos otro depósito que sea más preferible y tenga capacidad disponible, sin realizar antes algún otra modificación sobre la soluición como un swap, por ejemplo. En cambio, en nuestra segunda heurística sí ofrecería mejoras desde el incio, ya que que cada depósito tenga asignado los negocios más cercanos, nada asegura que cada negocio este asignado a su depósito más cercano. Consecuentemente, en dicho caso el operador relocate sería útil.

El operador relocate nos permite asignar los negocios que no era posible asignar a ningún depósito dadas las capacidades y las asignaciones ya realizadas. Se sufría una gran penalización sobre el valor objetivo por cada negocio no asignado, por lo cual el hecho de poder incluirlos en la solución mejora considerablemente el valor objetivo. Por supuesto, no se podrán ubicar dichos negocios sin antes haberse realizados otros relocate que generen suficiente espacio en algún depósito.

#### Operador 2: swap

El segundo operador que diseñamos es un swap. Este itera por los negocios, en busca de dos negocios que al intercambiar el depósito en el que se encuentran el valor objetivo disminuya, respetando las capacidades. Utilizamos de nuevo el criterio de *first improvement*. Este operador no servirá para añadir los negocios no asignados a la solución, ya que swapearlos simplemente añadiría un negocio para quitar otro.

Para aceptar una nueva solución debemos evaluar 2 condiciones, con $i_1$ el depósito A, $i_2$ el depósito B depósito, $j_1$ el negocio A (asignado al depósito A) y $j_2$ el negocio B (asignado al depósito B):

-   $c_{i_1j_1} + c_{i_2j_2} > c_{i_1j_2} + c_{i_2j_1}$

-   $d_{i_1j_2} \leq \bar{c}_{i_1} + d_{i_1j_1}$

-   $d_{i_2j_1} \leq \bar{c}_{i_2}+d_{i_2j_2}$

Con $\bar{c}_k$ la capacidad restante del depósito $k$.
