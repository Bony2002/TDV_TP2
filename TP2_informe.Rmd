---
title: ''
output:
  word_document: default
  pdf_document: default
  html_document: default
date: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## TP2: Logística centralizada de primera milla

### Introducción al problema

La problemática a abordar se trata de encontrar la manera óptima, o en su defecto efectiva, de realizar una asignación. Trabajaremos sobre un caso particular en el cual buscamos asignar un conjunto $N$ de negocios a un conjunto $M$ de depósitos. Cada negocio posee una distancia a cada depósito, denotada por $c_{ij}$, con $i\in{M}$ y $j \in{N}$. También posee una demanda, $d_{ij}$ que se refiere a la cantidad de stock que el negocio pedirá de dicho depósito. Por último, cada depósito posee un capacidad, denotada por $c_i$. En el este caso particular, los negocios no pueden pedir stock de distintos depósitos, por lo cual serán asignados tan solo a uno de estos. Asimismo, la demanda de cada negocio será la misma para todo depósito, por lo cual la variable $d_{ij}$ no depende de $i$ y podría escribirse como $d_j$. Consideramos una solución óptima al problema de asignación a aquella que minimiza la suma de las distancias entre cada negocio y cada depósito asignados, teniendo en cuenta no exceder la capacidad de estos últimos.

El tipo de problema con el cual trataremos es conocido como *GAP* (Generalized Assignment Problem), y su versión de optimización se encuentra en la categoría NP-Hard. Esto quiere decir que todo problema perteneciente a la clase NP puede ser reducido polinomialmente a *GAP*. Además, un problema NP-Hard no necesariamente pertenece a NP, es decir que no necesariamente existe un algoritmo polinomial para verificar un certificado positivo de una instancia del problema. Si encontraramos un algoritmo polinomial para *GAP* entonces encontraríamos una solución polinomial para todo problema en NP y demostraríamos que P = NP. De todos modo, eso aún no ha sucedido y es por eso que se desarrollan heurísticas para resolver el problema *GAP,* buscando un balance entre la complejidad temporal y la calidad de la solución.

En el siguiente trabajo buscamos modelar distintas alternativas de heurísticas y búsquedas locales en pos de hallar una solución de cierta calidad para la problemática GAP, en tiempo polinomial. Comenzaremos diseñando heurísticas constructivas, luego operadores de búsqueda local y por último generaremos una metaheurística que los englobe.

<p> </p>

### Diseño de heurísticas constructivas

#### Heurística 1: depósito más cercano

En primer lugar diseñamos e implementamos una heurística cuyo funcionamiento es el siguiente: por cada negocio buscamos el depósito más cercano, es decir aquel cuyo $c_{ij}$ sea el menor, y asignamos el negocio a dicho depósito. Asimismo, vamos disminuyendo la capacidad $c_j$ del depósito en función a la demanda $d_{ij}$ de la asignación. En caso de que el depósito de menor distancia a un negocio no tenga capacidad restante suficiente, este sería asignado al próximo depósito más cercano.

Esta heurística es posiblemente la más intuitiva, y tiene ciertas ventajas como no necesitar actualizar una lista de disponibilidad, ya que los depósitos pueden tener tantos negocios asignados como su capacidad permita. En otros enfoques, es necesario llevar la cuenta de qué negocios ya fueron asignados, pero en este caso al iterar por negocios y en cada iteración asignarlos a un depósito, no tenemos dicho problema.

La complejidad de este algoritmo goloso es $O(n m)$ siendo $n$ la cantidad de negocios y $m$ la cantidad de depósitos. Como vemos, es polinomial. Claramente no encontraremos la solución óptima, pero encontraremos una solución que creemos que tendrá cierto grado de efectividad.

#### Heurística 2: negocio más cercano

En segundo lugar desarollamos una heurística que funciona de manera inversa a la primera, es decir que itera por cada depósito y le asigna aquellos negocios que se encuentren cerca, mientras la capacidad del depósito lo permita. Es importante asegurarse que no se evalúen aquellos negocios que ya han sido asignados, por lo cual debemos llevar la cuenta de estos. Además, es necesario encontrar un modo de definir qué quiere decir que un negocio está cerca de un depósito. Nuestro criterio fue el siguiente: por cada depósito, ordenamos los negocios en función a cuán lejos estan de este, de menor a mayor. Así, iteramos por los depósitos asignandoles en orden los negocios mientras estos aún no esten asignados y mientras la capacidad del depóstio sea mayor a la demanda del negocio. A grandes rasgos, asignamos a cada depósito los negocios más cercanos a él.

La complejidad de este algoritmo goloso es de $O(n^2m)$, polinomial pero no tan eficiente como la heurística anterior.

Analizando el funcionamiento de neustra heurística, llegamos a la conclusión de que el orden en que evaluamos los depósitos alterará el resultado. Luego, quizás podríamos definir un orden de manera que ayude a reducir aún más el valor de la función objetivo. El primer depósito tenido en cuenta tendrá prioridad sobre los otros y será probablemente el único que tenga todos los negocios más cercanos a él asignados. Imaginemos la situación en la cual existe un depósito considerablemente más alejado de los negocios que el resto. Si este depósito es considerado antes que el resto, se le asignarán múltiples negocios que a pesar de estar más cerca del depósito que otros negocios, claramente estarán más cerca de los otros depósitos que de aquel en cuestión. Así, estaríamos dando mucho peso a un depósito al cual deberíamos tratar de asignarle la menor cantidad de negocios posibles. Luego, podría ser útil ordenar los depósitos según distancia promedio a los negocios y comenzar por aquellos con menor promedio. Así, evitarímos situaciones como la descripta anteriormente. Aquí partimos de la base de que la suma de las capacidades de los depósitos sea mayor a la suma de las demandas de los negocios, por lo cual preferimos que los depósitos "más vacíos" sean aquellos más lejanos. Si la situación fuera diferente entonces priorizar por cercanía los depósitos quizás no se necesario.

#### Consideraciones

Se pueden diseñar heurísticas que tomen un enfoque reacionado a las demandas que tiene cada negocio en relación a cada depósito, buscando quizás asignar negocios a depósitos de los cuales ocupen menor capacidad si es que dichos depósitos son cercanos a otros negocios y buscamos asignarlos a la mayor cantidad posible de negocios. Pueden surgir muchos matices considerando las demandas y capacidades. De todos modos, a pesar de que en el problema general de GAP las demandas de los negocios pueden variar dependiendo del depósito, como en nuestra instancia real todo negocio demanda lo mismo de cualquier depósito, no profundizaremos en estas alternativas. A pesar de estar diseñando una heurística para GAP en general, nuestro objetivo final se refiere en específico a la instancia particular de *ThunderPack*.

<p> </p>

### Operadores de búsqueda local

#### ¿Cómo representamos una solución?

Por una cuestión de comodidad al momento de implementar los distintos métodos, diseñamos dos maneras distintas de representar la solución. Por un lado generamos un vector de vectores de enteros llamado asignaciones, donde por cada depósito guardamos los índices de los negocios asignados a él. Así, `asignaciones[1][3] = 45` quiere decir que el negocio 45 se encuentra asignado al segundo depósito. Por otro lado generamos un vector de enteros llamado correspondencia en el cual cada índice representa un negocio y su valor representa el depósito al cual fue asignado. Así, `correspondencia[68] = 0` quiere decir que el negocio 67 (ya que incluímos al 0) fue asignado depósito 1. Actualizamos ambos paralelamente, de manera de que siempre representen la misma asignación.

#### Operador 1: relocate

El primer operador que definimos es un relocate. Este itera por los negocios evaluando si hay algún depósito con menor distancia al negocio que aquel al cual se encuentra asignado actualmente, y en caso afirmativo, si las capacidades lo permiten, asigna el negocio a su nuevo depósito. Definimos como vecindario a todas las soluciones alcanzables desde mi solución actual haciendo un único relocate. Utilizamos como criterio de aceptación el *first improvement*, y por lo tanto apenas hallamos una solución mejor a la actual redifinimos nuestra solución como la nueva y continuamos explorando su nuevo vecindario.

Para aceptar una nueva solución debemos evaluar 2 condiciones, con $i_1$ el depósito anterior, $i_2$ el nuevo depósito y $j$ el negocio:

-   $c_{i_2j} < c_{i_1j}$

-   $d_{i_2j} \leq c_{i_2}$ , siendo $c_{i_2}$ la capacidad restante del depósito $i_2$

Este operador no aportará una mejora con toda heurística posible como base para la solución inicial. Por ejemplo, si tomamos nuestra primer heurística, como cada negocio está asignado al depósito más cercano, nunca encontraremos otro depósito que sea más preferible y tenga capacidad disponible, sin realizar antes algún otra modificación sobre la soluición como un swap, por ejemplo. En cambio, en nuestra segunda heurística sí ofrecería mejoras desde el incio, ya que que cada depósito tenga asignado los negocios más cercanos, nada asegura que cada negocio este asignado a su depósito más cercano. Consecuentemente, en dicho caso el operador relocate sería útil.

El operador relocate nos permite asignar los negocios que no era posible asignar a ningún depósito dadas las capacidades y las asignaciones ya realizadas. Se sufría una gran penalización sobre el valor objetivo por cada negocio no asignado, por lo cual el hecho de poder incluirlos en la solución mejora considerablemente el valor objetivo. Por supuesto, no se podrán ubicar dichos negocios sin antes haberse realizados otros relocate que generen suficiente espacio en algún depósito.

La complejidad del opeador relocate es de $O(nm)$ siendo $n$ la cantidad de negocios y $m$ la cantidad de depósitos. Notemos que la búsqueda corre hasta haber analizado todas las posibles combinaciones de negocios y depósitos, realizando las alteraciones de la solución simultánemante.

#### Operador 2: swap

El segundo operador que diseñamos es un swap. Este itera por los negocios, en busca de dos negocios que al intercambiar el depósito en el que se encuentran el valor objetivo disminuya, respetando las capacidades. Utilizamos de nuevo el criterio de *first improvement*. Este operador no servirá para añadir los negocios no asignados a la solución, ya que swapearlos simplemente añadiría un negocio para quitar otro.

Para aceptar una nueva solución debemos evaluar 2 condiciones, con $i_1$ el depósito A, $i_2$ el depósito B depósito, $j_1$ el negocio A (asignado al depósito A) y $j_2$ el negocio B (asignado al depósito B):

-   $c_{i_1j_1} + c_{i_2j_2} > c_{i_1j_2} + c_{i_2j_1}$

-   $d_{i_1j_2} \leq \bar{c}_{i_1} + d_{i_1j_1}$

-   $d_{i_2j_1} \leq \bar{c}_{i_2}+d_{i_2j_2}$

Con $\bar{c}_k$ la capacidad restante del depósito $k$.

Pareciera que este operador funcionará con ambas heurísticas diseñadas ya que siempre puede suceder que las suma de las nuevas distancias sea menor que la suma de las anteriores.

La complejidad del operador swap es de $O(n^2)$ siendo $n$ la cantidad de negocios, ya que la búsqueda evalúa cada par de negocios posible en busca de una mejora al valor objetivo.

¿Qué podría hacer a una solución infactible? En primer lugar que la suma de las demandas de los negocios asignados a cierto depósito superen su capacidad. En segundo lugar, que un negocio sea asignado a más de un depósito. Ambos operadores evalúan que las capacidades de los depósitos no sean excedidos. Asimismo, no permiten que un negocio peretenezca a dos depósitos: el operador relocate quita al negocio del depósito anterior al relocalizarlo y el operador swap quita a ambos negocios de sus anteriores depósitos. Luego, ambos son correctos.

<p> </p>

### Metaheurística

Como metaheurística diseñamos una variación de VND (variable neighbourhood descent) utilizando ambos vecindarios, swap y operate. Tiene ciertas diferencias con el concepto de VND, ya que itera dentro de cada operador hasta alcanzar un mínimo local.

Definimos a $N_1$ como el operador relocate y a $N_2$ como el operador swap. Comenzamos investigando el vecindario $N_1$, buscando una solución mejor y pasando al vecindario de dicha solución hasta llegar a un mínimo local. Luego, comenzamos a investigar con el vecindario $N_2$ del mismo modo. Cuando llegamos a un mínimo local, retornamos a analizar el vecindario $N_1$. Alteramos entre ambos vecindarios de este modo hasta que ninguno ofrece una mejora a la solución, es decir, nos encontramos en una solución que es un mínimo local para ambos. En dicho caso, retornamos la solución como el mínimo obtenido por la metaheurística.

¿Cuál es la calidad de la solución? Nada nos asegura que la solución hallada por nuestra metaheurística sea efectivamente la solución óptima. Es muy probable que no lo sea. De todos modos, a partir de experimentación que explicaremos a continuación, notamos que cuánto realmente mejora la solución inicial depende en un alto grado de la calidad de la heurística llevada a cabo.

Idealmente, podríamos resolver una vez el problema con un algoritmo exacto, obteniendo el óptimo, y así podríamos determinar con mayor seguridad la calidad de nuestras soluciones aproximadas. Por otro lado, la solución inicial, y en mayor escala la heurística, genera un gran impacto en la metaheurística. Puede suceder que una heurística que genera una "peor" solución inicial nos de un mayor espacio a mejoras. Puede suceder que nuestra heurística sea muy buena y por lo tanto no podamos mejorar. Las posibilidades son múltiples, y dependen de variados factores, como también la naturaleza de la instancia que evaluamos.

La complejidad de la metaheurística depende de cuantas iteraciones se realicen de esta, lo cual no es posible definir de antemano. Los operadores relocate y swap que utiliza son de complejidad $O(nm)$ y $O(n^2)$ respectivamente por lo cual por supuesto la complejidad de la metaheurística es al menos de $O(max(nm, n^2))$. La complejidad depende de la cantidad de iteraciones, es decir de la cantidad de soluciones mejores hacia las cuales nos movemos, por lo cual podríamos decir que depende de cuán cerca está nuestra solución inicial de un mínimo local para ambos operadores, lo cual depende de nuevo de la heurística utilizada para obtener dicha solución inicial.

<p> </p>

### Experimentación y discusión

Para evaluar el funcionamiento y calidad de nuestras heurísticas, búsquedas locales y por úlitmo metaheurística, utilizamos tres conjuntos de bases de datos.

Podemos observar que en ningún caso varía el valor objetivo entre la heurística 1 y la heurística 1 en conjunto con el operador relocate. Esto tiene mucho sentido, ya que el operador relocate busca por cada negocio un depósito más cercano al que tiene asignado y con capacidad suficiente para satisfacer su demanda, pero dado que la heurística 1 ubica siempre a los negocios en el depósito a menor distancia con capacidad disponible, nunca habrá una mejora de este tipo para realizar.

<p> </p>

### Análisis del caso real

Nuestro caso real se trata de la problemática de la empresa ThunderPack, la cual posee 1100 negocios, 310 depósitos y busca encontrar una asignación que sea lo más efectiva posible. Asimismo, tiene la particularidad de que la demanda de los negocios es la misma para cada depósito, es decir que el parámetro $d_{ij}$ no depende del depósito $i$ y por lo tanto se puede escribir como $d_j$.

A continuación mostramos en una tabla los valores obetivos obtenidos a través de distintas combinaciones de las herramientas desarrolladas en este proyecto:

|          | **H1**    | **H2**     | **H1+BL1** | **H1+BL2** | **H2+BL1**        | **H2+BL2** | **MH1**    | **MH2**    |
|----------|-----------|------------|------------|------------|-------------------|------------|------------|------------|
| **V.O.** | 788.2     | 1781.1     | 788.2      | 740.7      | 1354.4            | 1361.9     | 733.6      | 722.4      |
| **T.E.** | 6.0978 ms | 1226.13 ms |            | 100.088 ms | 1226.13 ms ??'??? | 1320.12 ms | 748.603 ms | 2059.58 ms |

Referencias:

**H1** = Heurística 1 (negocio más cercano)

**H2** = Heurística 2 (depósito más cercano)

**BL1** = Búsqueda local 1 (relocate)

**BL2** = Búsqueda local 2 (swap)

**MH1** = Metaheurística con solución inicial obtenida a través de la heurística 1

**MH2** = Metaheurística con solución inicial obtenida a través de la heurística 2

**V.O.** = valor objetivo

**T.E.** = tiempo de ejecución en milisegundos

Observando la tabla podemos ver que en el caso real la heurística 1 es ampliamente más efectiva que la heurística 2, siendo 2.6 veces más grande el valor objetivo de esta última. Recordemos que nuestro ojetivo es la minimización. El operador relocate no genera ningún cambio sobre la solución de la heurística 1, como fue explicado previamente, y mejora en un 24% a la solución de la heurística 2. Por otro lado, el operador swap genera una mejora de 6% sobre la heurística 1 y una mejora de 23.5% sobre la heurística 2. Por último, la metaheurística devuelve una solución un 7% mejor que la heurística 1 y un 60% mejor que la heurística 2.

Podemos observar que la solución de la heurística 2 tiene mucho espacio para ser mejorada, mientras que la heurística 1 varía en un grado muy pequeño. Esto claramente no quiere decir que la heurística 2 sea mejor, ya que la solución ofrecida por esta tiene un valor objetivo significativamente peor que la solución de la heurística 1.

Una observación curiosa es que la metaheurística aplicada partiendo de una solución inicial generada con la heurística 2 obtiene un valor objetivo menor que cuando es aplicada sobre la heurística 1, a pesar de que la solución incial de esta última sea ampliamente menor. Como hemos mencionado antes, existen tanto factores en juego al utilizar estas herramientas que las posibilidades varían ampliamente y no siempre encontraremos una regla fija que establezca la superioridad de un método frente a otros.

En relación al tiempo de ejecución,

Analizando las asignaciones generadas por ambas heurísticas

VER CUANTOS QUEDAN SIN ASIGNAR EN CADA HEURISTICA !!!
